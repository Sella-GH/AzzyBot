using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AzzyBot.SourceGenerators
{
    [Generator]
    public class DiscordChoiceProviderGenerator : ISourceGenerator
    {
        private const string AttributeSource = @"using System;

#nullable enable
namespace AzzyBot.Bot.Utilities.Attributes
{
    /// <summary>
    /// Marks a static class for Discord choice provider generation.
    /// The class should contain a public static field named 'Choices' with choice data.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false)]
    public sealed class DiscordChoiceProviderAttribute : Attribute
    {
        /// <summary>
        /// Gets the name of the generated choice provider class.
        /// If not specified, uses the class name with ""Provider"" suffix.
        /// </summary>
        public string? ProviderName { get; set; }
    }
}";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new DiscordChoiceProviderSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Add the attribute source to the compilation
            context.AddSource("DiscordChoiceProviderAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));

            // Add a debug file to see if the generator is running
            context.AddSource("Debug.g.cs", SourceText.From("// Source Generator is running!", Encoding.UTF8));

            if (!(context.SyntaxReceiver is DiscordChoiceProviderSyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;

            foreach (var candidateClass in receiver.CandidateClasses)
            {
                GenerateChoiceProvider(context, compilation, candidateClass);
            }
        }

        private static void GenerateChoiceProvider(GeneratorExecutionContext context, Compilation compilation, ClassDeclarationSyntax classDeclaration)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol == null)
                return;

            // Check if the class has the DiscordChoiceProviderAttribute
            var attributeData = classSymbol.GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == "DiscordChoiceProviderAttribute");

            if (attributeData == null)
                return;

            // Get the provider name from attribute or use class name + "Provider"
            string providerName = GetProviderName(attributeData, classSymbol.Name);
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // Find the Choices field
            var choicesField = classSymbol.GetMembers("Choices")
                .OfType<IFieldSymbol>()
                .FirstOrDefault(f => f.IsStatic);

            if (choicesField == null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "AZZY001",
                        "Missing Choices field",
                        "Class '{0}' marked with DiscordChoiceProvider must have a static Choices field",
                        "AzzyBot.SourceGenerators",
                        DiagnosticSeverity.Error,
                        true),
                    classDeclaration.GetLocation(),
                    classSymbol.Name));
                return;
            }

            var sourceCode = GenerateSourceCode(namespaceName, providerName);
            context.AddSource($"{providerName}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }

        private static string GetProviderName(AttributeData attributeData, string className)
        {
            var providerNameArg = attributeData.NamedArguments
                .FirstOrDefault(kvp => kvp.Key == "ProviderName");

            if (!providerNameArg.Equals(default) && providerNameArg.Value.Value is string customName)
                return customName;

            return className.EndsWith("Choices") ? className.Replace("Choices", "Provider") : $"{className}Provider";
        }

        private static string GenerateSourceCode(string namespaceName, string providerName)
        {
            string choicesClassName = providerName.Replace("Provider", "Choices");

            var code = new StringBuilder();
            code.AppendLine("///<auto-generated/>");
            code.AppendLine("#nullable enable");
            code.AppendLine("using System.Collections.Generic;");
            code.AppendLine("using System.Threading.Tasks;");
            code.AppendLine("using DSharpPlus.Commands.Processors.SlashCommands.ArgumentModifiers;");
            code.AppendLine("using DSharpPlus.Commands.Trees;");
            code.AppendLine("using DSharpPlus.Entities;");
            code.AppendLine();
            code.AppendLine($"namespace {namespaceName}");
            code.AppendLine("{");
            code.AppendLine($"    public sealed class {providerName} : IChoiceProvider");
            code.AppendLine("    {");
            code.AppendLine("        private static readonly List<DiscordApplicationCommandOptionChoice> _choices = CreateChoices();");
            code.AppendLine();
            code.AppendLine("        private static List<DiscordApplicationCommandOptionChoice> CreateChoices()");
            code.AppendLine("        {");
            code.AppendLine($"            var sourceChoices = {choicesClassName}.Choices;");
            code.AppendLine("            var choices = new List<DiscordApplicationCommandOptionChoice>();");
            code.AppendLine("            ");
            code.AppendLine("            foreach (var choice in sourceChoices)");
            code.AppendLine("            {");
            code.AppendLine("                choices.Add(new DiscordApplicationCommandOptionChoice(choice.Name, choice.Value));");
            code.AppendLine("            }");
            code.AppendLine("            ");
            code.AppendLine("            return choices;");
            code.AppendLine("        }");
            code.AppendLine();
            code.AppendLine("        public ValueTask<IEnumerable<DiscordApplicationCommandOptionChoice>> ProvideAsync(CommandParameter parameter)");
            code.AppendLine("            => ValueTask.FromResult<IEnumerable<DiscordApplicationCommandOptionChoice>>(_choices);");
            code.AppendLine("    }");
            code.AppendLine("}");

            return code.ToString();
        }
    }

    public class DiscordChoiceProviderSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration
                && classDeclaration.AttributeLists.Count > 0
                && classDeclaration.Modifiers.Any(SyntaxKind.StaticKeyword))
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}